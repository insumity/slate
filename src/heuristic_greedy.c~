#include <unistd.h>
#include <mctop.h>
#include <stdbool.h>
#include <semaphore.h>
#include <numaif.h>

#include "heuristic_greedy.h"
#include "list.h"

typedef struct {
  pin_data** pin;
  mctop_t* topo;
  int total_hwcs;

  list* policy_per_pid;
  list* hwcs_per_pid;
  list* tids_per_pid;
  
  bool* used_hwcs;

  sem_t* lock;
} H_global_state;

H_global_state state;

void HGREEDY_reschedule(pid_t pid, int new_policy) {
  printf("\n\n\n\n\nABOUT TO RESCHEDULE\n\n\n\n\n\n\n\n");
  int elems = 0;
  void** values = list_get_all_values(state.tids_per_pid, &pid, compare_pids, &elems);

  printf("Elements: %d\n", elems);
  for (int i = 0; i < elems; ++i) {
    printf("%d: TID: %ld\n", i, *(pid_t *) values[i]);
    //HGREEDY_release_hwc(*((pid_t *) values[i]));
    HGREEDY_release_hwc(pid);
  }
  HGREEDY_release_hwc(pid);

  list_remove(state.policy_per_pid, &pid, compare_pids);

  if (new_policy == MCTOP_ALLOC_BW_ROUND_ROBIN_CORES) {
    unsigned long old_nodes = 0xFF;
    unsigned long new_nodes = 0x01;
    if (migrate_pages(pid, 30,
		      &old_nodes,
		      &new_nodes) == -1) {
      perror("couldn't migrate memory\n");
    }
    else {
      printf(">>> memory migrated!\n");
    }
  }
  
  HGREEDY_new_process(pid, new_policy);
  int node;
  int core = HGREEDY_get_hwc(pid, pid, &node);
  pin(pid, core, node);

  for (int i = 0; i < elems; ++i) {
    pid_t tid = *((pid_t *) values[i]);
    int core = HGREEDY_get_hwc(pid, tid, &node);
    pin(tid, core, node);
  }

  if (new_policy != MCTOP_ALLOC_BW_ROUND_ROBIN_CORES) {
    for (int i = 0; i < elems; ++i) {
      pid_t tid = *((pid_t *) values[i]);
      unsigned long old_nodes = 0xFF;
      unsigned long new_nodes = 0x1;
      if (migrate_pages(tid, 30,
			&old_nodes,
			&new_nodes) == -1) {
	perror("couldn't migrate memory\n");
      }
      else {
	printf(">>>>!!! memory migrated\n");
	;
      }
    }

  }
}

void HGREEDY_init(pin_data** pin, mctop_t* topo) {
  state.pin = pin;
  state.topo = topo;

  size_t num_nodes = mctop_get_num_nodes(topo);
  size_t num_cores_per_socket = mctop_get_num_cores_per_socket(topo);
  size_t num_hwc_per_core = mctop_get_num_hwc_per_core(topo);
  state.total_hwcs = num_nodes * num_cores_per_socket * num_hwc_per_core;

  state.policy_per_pid = create_list();
  state.hwcs_per_pid = create_list();
  state.tids_per_pid = create_list();

  
  state.used_hwcs = malloc(sizeof(bool) * state.total_hwcs);
  for (int i = 0; i < state.total_hwcs; ++i) {
    state.used_hwcs[i] = false;
  }
  
  state.lock = malloc(sizeof(sem_t));
  if (sem_init(state.lock, 0, 1)) {
    perror("couldn't create lock for state\n");
  }
}

sem_t* HGREEDY_get_lock() {
  return state.lock;
}

void HGREEDY_new_process(pid_t pid, int policy) {
  pid_t* pid_pt = malloc(sizeof(pid_t));
  *pid_pt = pid;

  int* policy_pt = malloc(sizeof(int));
  *policy_pt = policy;

  if (policy == MCTOP_ALLOC_NONE) {
    int* tmp = malloc(sizeof(int));
    *tmp = -1;
    list_add(state.hwcs_per_pid, pid_pt, tmp);
    list_add(state.policy_per_pid, pid_pt, policy_pt);
    return;
  }

  int* tmp = malloc(sizeof(int));
  *tmp = -2;
  list_add(state.hwcs_per_pid, pid_pt, tmp);
  list_add(state.policy_per_pid, pid_pt, policy_pt);
}

void HGREEDY_process_exit(pid_t pid) {
  //list_remove(state.hwcs_per_pid, &pid, compare_pids); // already done by leave_process
}


int HGREEDY_get_hwc(pid_t pid, pid_t tid, int* ret_node) {

  /* void* tmp_pt = list_get_value(state.hwcs_per_pid, &pid, compare_pids); */
  /* if (tmp_pt != NULL && *(int *) tmp_pt == -2) { */
  /*   list_remove(state.hwcs_per_pid, &pid, compare_pids); */
  /* } */
  
  void* policy_pt;
  do {
    policy_pt = list_get_value(state.policy_per_pid, &pid, compare_pids);
    usleep(5000);
  } while (policy_pt == NULL);
  int policy = *((int *) policy_pt);

  if (policy == MCTOP_ALLOC_NONE) {
    *ret_node = -1;

    int* tmp = malloc(sizeof(int));
    *tmp = -1;

    pid_t* pid_pt = malloc(sizeof(pid_t));
    *pid_pt = pid;

    pid_t* tid_pt = malloc(sizeof(pid_t));
    *tid_pt = tid;

    if (pid != tid) {
      list_add(state.tids_per_pid, pid_pt, tid_pt);
    }
    
    list_add(state.hwcs_per_pid, tid_pt, tmp);

    return -1;
  }

  
  // go through all the hwcs
  int cnt = 0;
  int hwc;
  while (cnt < state.total_hwcs) {
    pin_data pd = state.pin[policy][cnt];
    hwc = pd.core;
    int node = pd.node;
    *ret_node = node;

    if (!state.used_hwcs[hwc]) {
      goto end;

    }

    cnt++;
  }


  // update global state
 end: ;
  state.used_hwcs[hwc] = true;

  int*n = malloc(sizeof(int));
  *n = hwc;

  pid_t* pid_pt = malloc(sizeof(pid_t));
  *pid_pt = pid;

  pid_t* tid_pt = malloc(sizeof(pid_t));
  *tid_pt = tid;

  list_add(state.hwcs_per_pid, tid_pt, n);

  if (pid != tid) {
    list_add(state.tids_per_pid, pid_pt, tid_pt);
  }
  
  return hwc;
}

void HGREEDY_release_hwc(pid_t pid) {
  sem_wait(state.lock);
  int hwc = *((int *) list_get_value(state.hwcs_per_pid, &pid, compare_pids));
  
  if (hwc == -1) {
    sem_post(state.lock);
    return;
  }
  
  state.used_hwcs[hwc] = false;
  
  list_remove(state.hwcs_per_pid, &pid, compare_pids);
  int res = list_remove(state.tids_per_pid, &pid, compare_pids);
  if (res == 1) {
    printf("REMoved %lld\n", (long int) pid);
  }
  else {
    printf("Couldn't remove:  %lld\n", (long int) pid);
  }

  sem_post(state.lock);
}

